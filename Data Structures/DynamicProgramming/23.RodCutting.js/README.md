We are given a rod of size ‘N’. It can be cut into pieces. Each length of a piece has a particular price given by the price array. Our task is to find the maximum revenue that can be generated by selling the rod after cutting( if required) into pieces.

Example -
Input:
N = 5
price -= [2,5,7,8,10]
length in which rod can be cut = 1, 2, 3, 4, 5
Output:  1 + 2 + 2 => (2 + 5 + 5 = 12)


## Solution 
Pick and not pick (pick of the same value can be any number of times)

### Recursion
1. Express the problem in terms of indexes.-> index, lengthOFRodLeft
2. Top down approach so we move from n-1 to 0 indexes,  can be picked or not picked in each recurrence
3. Base case -> 1. if index = 0 , and return => price[0] * lengthOFRodLeft
4. Recurrence relation -> take => f(ind, lengthOFRodLeft - wt[ind]) + val[ind], notTake = f(ind -1, lengthOFRodLeft)
   f(ind,lengthOFRodLeft) = max(take, notTake)

### Memo
introduce dp => 2D => [ind][lengthOFRodLeft + 1]

### Tabulation
1. we take a 2D DP [arr.length][lengthOFRodLeft + 1]=> initialise with 0
2. base case ->  At ind==0, for all w from 0 -> lengthOFRodLeft, dp[0][w] = (w/wt[0]) * val[0]
3. loop for all the rows => i = 1 to  n-1 and w = 0 to lengthOFRodLeft, calculate the take and not take 
   take = lengthOFRodLeft - w[ind] >=0 ? val[ind] + dp[ind][lengthOFRodLeft - w[ind]] : -Infinity
   notTake = 0 + dp[ind-1][lengthOFRodLeft]
4. return dp[n-1][lengthOFRodLeft]   

### Space optimisation
1. prev will be a lengthOFRodLeft + 1 size array and same cur and fill with 0 
2. At ind==0, for all w from 0 -> lengthOFRodLeft, dp[0][w] = (w/wt[0]) * val[0]
3. loop through i(1 to n-1) and w(0 to lengthOFRodLeft) , and take and not take will use prev and we will calculate cur,
   after loop ends for col , prev = cur;
4. return prev[lengthOFRodLeft]